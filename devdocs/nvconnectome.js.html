<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>nvconnectome.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ColorTables_ColorTables.html">ColorTables</a></li><li><a href="NVConnectome.html">NVConnectome</a><ul class='methods'><li data-type='method'><a href="NVConnectome.html#findClosestConnectomeNode">findClosestConnectomeNode</a></li><li data-type='method'><a href="NVConnectome.html#.loadConnectomeFromUrl">loadConnectomeFromUrl</a></li></ul></li><li><a href="NVController.html">NVController</a><ul class='methods'><li data-type='method'><a href="NVController.html#connectToSession">connectToSession</a></li><li data-type='method'><a href="NVController.html#onAzimuthElevationChangeHandler">onAzimuthElevationChangeHandler</a></li><li data-type='method'><a href="NVController.html#onClipPlaneChangeHandler">onClipPlaneChangeHandler</a></li><li data-type='method'><a href="NVController.html#onColormapChangeHandler">onColormapChangeHandler</a></li><li data-type='method'><a href="NVController.html#onCustomMeshShaderAddedHandler">onCustomMeshShaderAddedHandler</a></li><li data-type='method'><a href="NVController.html#onFrameChangeHandler">onFrameChangeHandler</a></li><li data-type='method'><a href="NVController.html#onImageLoadedHandler">onImageLoadedHandler</a></li><li data-type='method'><a href="NVController.html#onMeshAddedFromUrlHandler">onMeshAddedFromUrlHandler</a></li><li data-type='method'><a href="NVController.html#onMeshLoadedHandler">onMeshLoadedHandler</a></li><li data-type='method'><a href="NVController.html#onMeshPropertyChanged">onMeshPropertyChanged</a></li><li data-type='method'><a href="NVController.html#onMeshShaderChanged">onMeshShaderChanged</a></li><li data-type='method'><a href="NVController.html#onOpacityChangeHandler">onOpacityChangeHandler</a></li><li data-type='method'><a href="NVController.html#onVolumeAddedFromUrlHandler">onVolumeAddedFromUrlHandler</a></li><li data-type='method'><a href="NVController.html#onVolumeWithUrlRemovedHandler">onVolumeWithUrlRemovedHandler</a></li><li data-type='method'><a href="NVController.html#onZoom3DChangeHandler">onZoom3DChangeHandler</a></li></ul></li><li><a href="NVDocument.html">NVDocument</a><ul class='methods'><li data-type='method'><a href="NVDocument.html#addImageOptions">addImageOptions</a></li><li data-type='method'><a href="NVDocument.html#download">download</a></li><li data-type='method'><a href="NVDocument.html#getImageOptions">getImageOptions</a></li><li data-type='method'><a href="NVDocument.html#hasImage">hasImage</a></li><li data-type='method'><a href="NVDocument.html#hasImageFromUrl">hasImageFromUrl</a></li><li data-type='method'><a href="NVDocument.html#json">json</a></li><li data-type='method'><a href="NVDocument.html#removeImage">removeImage</a></li><li data-type='method'><a href="NVDocument.html#.deserializeMeshDataObjects">deserializeMeshDataObjects</a></li><li data-type='method'><a href="NVDocument.html#.loadFromJSON">loadFromJSON</a></li></ul></li><li></li><li></li><li><a href="NVLabel3D_NVLabel3D.html">NVLabel3D</a></li><li><a href="NVLabel3DStyle.html">NVLabel3DStyle</a></li><li><a href="NVMesh.html">NVMesh</a><ul class='methods'><li data-type='method'><a href="NVMesh.html#.loadFromBase64">loadFromBase64</a></li><li data-type='method'><a href="NVMesh.html#.loadFromFile">loadFromFile</a></li><li data-type='method'><a href="NVMesh.html#.loadFromUrl">loadFromUrl</a></li></ul></li><li><a href="global.html#NVMeshFromUrlOptions">NVMeshFromUrlOptions</a></li><li><a href="NVMeshLoaders.html">NVMeshLoaders</a></li><li><a href="NVMeshUtilities.html">NVMeshUtilities</a></li><li><a href="NVMessage.html">NVMessage</a></li><li><a href="NVMessageSet4DVolumeIndexData.html">NVMessageSet4DVolumeIndexData</a></li><li><a href="NVMesssageUpdateData.html">NVMesssageUpdateData</a></li><li><a href="NVUtilities.html">NVUtilities</a></li><li><a href="NiivueObject3D.html">NiivueObject3D</a></li><li><a href="SessionBus.html">SessionBus</a></li><li><a href="SessionUser.html">SessionUser</a></li><li><a href="Shader.html">Shader</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DRAG_MODE">DRAG_MODE</a></li><li><a href="global.html#LabelLineTerminator">LabelLineTerminator</a></li><li><a href="global.html#LabelTextAlignment">LabelTextAlignment</a></li><li><a href="global.html#MULTIPLANAR_TYPE">MULTIPLANAR_TYPE</a></li><li><a href="global.html#MeshType">MeshType</a></li><li><a href="global.html#NVMESSAGE">NVMESSAGE</a></li><li><a href="global.html#SLICE_TYPE">SLICE_TYPE</a></li><li><a href="global.html#storageAvailable">storageAvailable</a></li><li><a href="global.html#utiltiesLogger">utiltiesLogger</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">nvconnectome.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { NVMesh, MeshType } from './nvmesh'
import { NVUtilities } from './nvutilities'
import { NiivueObject3D } from './niivue-object3D'
import { NVMeshUtilities } from './nvmesh-utilities'
import { cmapper } from './colortables'
import { NVLabel3D, LabelTextAlignment } from './nvlabel'

/**
 * Representes the vertices of a connectome
 * @typedef {Object} NVConnectomeNode
 * @property {string} name - name of node
 * @property {number} x
 * @property {number} y
 * @property {number} z
 * @property {number} colorValue - color value of node (actual color determined by colormap)
 * @property {number} sizeValue - size value of node (actual size determined by node scale times this value in mms)
 * @property {NVLabel3D} label
 */

/**
 * Represents edges between connectome nodes
 * @typedef {Object} NVConnectomeEdge
 * @property {number[]} firstNodeIndex - index of first node
 * @property {number[]} secondNodeIndex - index of second node
 * @property {number} colorValue - color value to determin color of edge based on color map
 */
export class NVConnectomeEdge {
  contructor(first, second, colorValue) {
    this.first = first
    this.second = second
    this.colorValue = colorValue
  }
}

const defaultOptions = {
  name: 'untitled connectome',
  nodeColormap: 'warm',
  nodeColormapNegative: 'winter',
  nodeMinColor: 0,
  nodeMaxColor: 4,
  nodeScale: 3,
  edgeColormap: 'warm',
  edgeColormapNegative: 'winter',
  edgeMin: 2,
  edgeMax: 6,
  edgeScale: 1
}

/**
 * @typedef {Object} NVConnectomeOptions
 * @property {string} name
 * @property {string} nodeColormap
 * @property {string} nodeColormapNegative
 * @property {number} nodeMinColor
 * @property {number} nodeMaxColor
 * @property {number} nodeScale - scale factor for node, e.g. if 2 and a node has size 3, a 6mm ball is drawn
 * @property {string} edgeColormap
 * @property {string} edgeColormapNegative
 * @property {number} edgeMin
 * @property {number} edgeMax
 * @property {number} edgeScale
 * @property {number} legendLineThickness
 */
// export class NVConnectomeOptions extends NVMeshOptions {}
/**
 * Represents a connectome
 */
export class NVConnectome extends NVMesh {
  /**
   * @constructor
   * @param {NVConnectomeOptions} connectome
   */
  constructor(gl, connectome) {
    super([], [], connectome.name, [], 1.0, true, gl, connectome)
    this.gl = gl
    // this.nodes = connectome.nodes;
    // this.edges = connectome.edges;
    // this.options = { ...defaultOptions, ...connectome };
    this.type = MeshType.CONNECTOME
    if (this.nodes) {
      this.updateLabels()
    }

    this.nodesChanged = new EventTarget()
  }

  static convertLegacyConnectome(json) {
    const connectome = { nodes: [], edges: [] }
    for (const prop in json) {
      if (prop in defaultOptions) {
        connectome[prop] = json[prop]
      }
    }
    const nodes = json.nodes
    for (let i = 0; i &lt; nodes.names.length; i++) {
      connectome.nodes.push({
        name: nodes.names[i],
        x: nodes.X[i],
        y: nodes.Y[i],
        z: nodes.Z[i],
        colorValue: nodes.Color[i],
        sizeValue: nodes.Size[i]
      })
    }

    for (let i = 0; i &lt; nodes.length - 1; i++) {
      for (let j = i + 1; j &lt; nodes.length; j++) {
        const colorValue = this.edges[i * nodes.length + j]
        connectome.edges.push({
          first: i,
          second: j,
          colorValue
        })
      }
    }

    return connectome
  }

  static convertFreeSurferConnectome(json, colormap = 'warm') {
    let isValid = true
    if (!('data_type' in json)) {
      isValid = false
    } else if (json.data_type !== 'fs_pointset') {
      isValid = false
    }
    if (!('points' in json)) {
      isValid = false
    }
    if (!isValid) {
      throw Error('not a valid FreeSurfer json pointset')
    }

    const nodes = json.points.map((p) => ({
      name: Array.isArray(p.comments) &amp;&amp; p.comments.length > 0 &amp;&amp; 'text' in p.comments[0] ? p.comments[0].text : '',
      x: p.coordinates.x,
      y: p.coordinates.y,
      z: p.coordinates.z,
      colorValue: 1,
      sizeValue: 1,
      metadata: p.comments
    }))
    const connectome = {
      ...defaultOptions,
      nodeColormap: colormap,
      edgeColormap: colormap,
      nodes,
      edges: []
    }
    return connectome
  }

  updateLabels() {
    const nodes = this.nodes
    if (nodes.length > 0) {
      // largest node
      const largest = nodes.reduce((a, b) => (a.sizeValue > b.sizeValue ? a : b)).sizeValue
      const min = this.nodeMinColor
        ? this.nodeMinColor
        : nodes.reduce((a, b) => (a.colorValue &lt; b.colorValue ? a : b)).colorValue
      const max = this.nodeMaxColor
        ? this.nodeMaxColor
        : nodes.reduce((a, b) => (a.colorValue > b.colorValue ? a : b)).colorValue
      const lut = cmapper.colormap(this.nodeColormap, this.colormapInvert)
      const lutNeg = cmapper.colormap(this.nodeColormapNegative, this.colormapInvert)

      const hasNeg = 'nodeColormapNegative' in this
      const legendLineThickness = this.legendLineThickness ? this.legendLineThickness : 0.0

      for (let i = 0; i &lt; nodes.length; i++) {
        let color = nodes[i].colorValue
        let isNeg = false
        if (hasNeg &amp;&amp; color &lt; 0) {
          isNeg = true
          color = -color
        }

        if (min &lt; max) {
          if (color &lt; min) {
            console.log('color value lower than min')
            continue
          }
          color = (color - min) / (max - min)
        } else {
          color = 1.0
        }

        color = Math.round(Math.max(Math.min(255, color * 255)), 1) * 4
        let rgba = [lut[color], lut[color + 1], lut[color + 2], 255]
        if (isNeg) {
          rgba = [lutNeg[color], lutNeg[color + 1], lutNeg[color + 2], 255]
        }
        rgba = rgba.map((c) => c / 255)
        console.log('adding label for ', nodes[i])
        nodes[i].label = new NVLabel3D(
          nodes[i].name,
          {
            textColor: rgba,
            bulletScale: nodes[i].sizeValue / largest,
            bulletColor: rgba,
            lineWidth: legendLineThickness,
            lineColor: rgba,
            textScale: 1.0,
            textAlignment: LabelTextAlignment.LEFT
          },
          [nodes[i].x, nodes[i].y, nodes[i].z]
        )
        console.log('label for node:', nodes[i].label)
      }
    }
  }

  addConnectomeNode(node) {
    console.log('adding node', node)
    this.nodes.push(node)
    this.updateLabels()
    this.nodesChanged.dispatchEvent(new CustomEvent('nodeAdded', { detail: { node } }))
  }

  deleteConnectomeNode(node) {
    // delete any connected edges
    const index = this.nodes.indexOf(node)
    this.edges = this.edges.filter((e) => e.first !== index &amp;&amp; e.second !== index)
    this.nodes = this.nodes.filter((n) => n !== node)

    this.updateLabels()
    this.updateConnectome(this.gl)
    this.nodesChanged.dispatchEvent(new CustomEvent('nodeDeleted', { detail: { node } }))
  }

  updateConnectomeNodeByIndex(index, updatedNode) {
    this.nodes[index] = updatedNode
    this.updateLabels()
    this.updateConnectome(this.gl)
    this.nodesChanged.dispatchEvent(new CustomEvent('nodeChanged', { detail: { node: updatedNode } }))
  }

  updateConnectomeNodeByPoint(point, updatedNode) {
    if (!this.connectome.nodes) {
      throw new Error('Node to update does not exist')
    }
    const node = this.connectome.nodes.find((node) => NVUtilities.arraysAreEqual([node.x, node.y, node.z], point))
    if (!node) {
      throw new Error(`Node with point ${point} to update does not exist`)
    }
    const index = this.connectome.nodes.findIndex((n) => n === node)
    this.updateConnectomeNodeByIndex(index, updatedNode)
  }

  addConnectomeEdge(first, second, colorValue) {
    let edge = this.edges.find(
      (f) => (f.first === first || f.second === first) &amp;&amp; f.first + f.second === first + second
    )
    if (edge) {
      return edge
    }
    edge = { first, second, colorValue }
    this.edges.push(edge)
    this.updateConnectome(this.gl)
    return edge
  }

  deleteConnectomeEdge(first, second) {
    const edge = this.edges.find(
      (f) => (f.first === first || f.first === second) &amp;&amp; f.first + f.second === first + second
    )
    if (edge) {
      this.edges = this.edges.filter((e) => e !== edge)
    } else {
      throw new Error(`edge between ${first} and ${second} not found`)
    }
    this.updateConnectome(this.gl)
    return edge
  }

  /**
   *
   * @param {number[]} point
   * @param {number} distance
   * @returns {NVConnectomeNode|null}
   */
  findClosestConnectomeNode(point, distance) {
    if (!this.nodes || this.nodes.length === 0) {
      return null
    }

    let closeNodes = this.nodes.map((n, i) => ({
      distance: Math.sqrt(Math.pow(n.x - point[0], 2) + Math.pow(n.y - point[1], 2) + Math.pow(n.z - point[2], 2)),
      index: i
    }))

    closeNodes = closeNodes.filter((n) => n.distance &lt; distance)
    if (closeNodes) {
      closeNodes.sort((a, b) => a.distance - b.distance)
    } else {
      return null
    }

    return this.nodes[closeNodes[0].index]
  }

  updateConnectome(gl) {
    const tris = []
    const pts = []
    const rgba255 = []
    let lut = cmapper.colormap(this.nodeColormap, this.colormapInvert)
    let lutNeg = cmapper.colormap(this.nodeColormapNegative, this.colormapInvert)
    let hasNeg = 'nodeColormapNegative' in this
    let min = this.nodeMinColor
    let max = this.nodeMaxColor
    const nNode = this.nodes.length
    for (let i = 0; i &lt; nNode; i++) {
      const radius = this.nodes[i].sizeValue * this.nodeScale
      if (radius &lt;= 0.0) {
        continue
      }
      let color = this.nodes[i].colorValue
      let isNeg = false
      if (hasNeg &amp;&amp; color &lt; 0) {
        isNeg = true
        color = -color
      }
      if (min &lt; max) {
        if (color &lt; min) {
          continue
        }
        color = (color - min) / (max - min)
      } else {
        color = 1.0
      }
      color = Math.round(Math.max(Math.min(255, color * 255)), 1) * 4
      let rgba = [lut[color], lut[color + 1], lut[color + 2], 255]
      if (isNeg) {
        rgba = [lutNeg[color], lutNeg[color + 1], lutNeg[color + 2], 255]
      }
      const pt = [this.nodes[i].x, this.nodes[i].y, this.nodes[i].z]

      NiivueObject3D.makeColoredSphere(pts, tris, rgba255, radius, pt, rgba)
    }

    lut = cmapper.colormap(this.edgeColormap, this.colormapInvert)
    lutNeg = cmapper.colormap(this.edgeColormapNegative, this.colormapInvert)
    hasNeg = 'edgeColormapNegative' in this
    min = this.edgeMin
    max = this.edgeMax
    for (const edge of this.edges) {
      let color = edge.colorValue
      const isNeg = hasNeg &amp;&amp; color &lt; 0
      if (isNeg) {
        color = -color
      }
      const radius = color * this.edgeScale
      if (radius &lt;= 0) {
        continue
      }
      if (min &lt; max) {
        if (color &lt; min) {
          continue
        }
        color = (color - min) / (max - min)
      } else {
        color = 1.0
      }
      color = Math.round(Math.max(Math.min(255, color * 255)), 1) * 4
      let rgba = [lut[color], lut[color + 1], lut[color + 2], 255]
      if (isNeg) {
        rgba = [lutNeg[color], lutNeg[color + 1], lutNeg[color + 2], 255]
      }
      const pti = [this.nodes[edge.first].x, this.nodes[edge.first].y, this.nodes[edge.first].z]
      const ptj = [this.nodes[edge.second].x, this.nodes[edge.second].y, this.nodes[edge.second].z]
      NiivueObject3D.makeColoredCylinder(pts, tris, rgba255, pti, ptj, radius, rgba)
    }

    // calculate spatial extent of connectome: user adjusting node sizes may influence size
    const obj = NVMeshUtilities.getExtents(pts)

    this.furthestVertexFromOrigin = obj.mxDx
    this.extentsMin = obj.extentsMin
    this.extentsMax = obj.extentsMax
    const posNormClr = this.generatePosNormClr(pts, tris, rgba255)
    // generate webGL buffers and vao
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer)
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int32Array(tris), gl.STATIC_DRAW)
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer)
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(posNormClr), gl.STATIC_DRAW)
    this.indexCount = tris.length
  }

  updateMesh(gl) {
    this.updateConnectome(gl)
  }

  json() {
    const json = {}
    for (const prop in this) {
      if (prop in defaultOptions || prop === 'nodes' || prop === 'edges') {
        json[prop] = this[prop]
      }
    }
    return json
  }

  /**
   * Factory method to create connectome from options
   * @static
   * @param {WebGL2RenderingContext} gl
   * @param {string} url
   * @returns {NVConnectome}
   */
  static async loadConnectomeFromUrl(gl, url) {
    const response = await fetch(url)
    const json = await response.json()
    return new NVConnectome(gl, json)
  }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Tue Nov 28 2023 22:46:45 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
