<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>session-bus.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ColorTables_ColorTables.html">ColorTables</a></li><li><a href="NVConnectome.html">NVConnectome</a><ul class='methods'><li data-type='method'><a href="NVConnectome.html#findClosestConnectomeNode">findClosestConnectomeNode</a></li><li data-type='method'><a href="NVConnectome.html#.loadConnectomeFromUrl">loadConnectomeFromUrl</a></li></ul></li><li><a href="NVController.html">NVController</a><ul class='methods'><li data-type='method'><a href="NVController.html#connectToSession">connectToSession</a></li><li data-type='method'><a href="NVController.html#onAzimuthElevationChangeHandler">onAzimuthElevationChangeHandler</a></li><li data-type='method'><a href="NVController.html#onClipPlaneChangeHandler">onClipPlaneChangeHandler</a></li><li data-type='method'><a href="NVController.html#onColormapChangeHandler">onColormapChangeHandler</a></li><li data-type='method'><a href="NVController.html#onCustomMeshShaderAddedHandler">onCustomMeshShaderAddedHandler</a></li><li data-type='method'><a href="NVController.html#onFrameChangeHandler">onFrameChangeHandler</a></li><li data-type='method'><a href="NVController.html#onImageLoadedHandler">onImageLoadedHandler</a></li><li data-type='method'><a href="NVController.html#onMeshAddedFromUrlHandler">onMeshAddedFromUrlHandler</a></li><li data-type='method'><a href="NVController.html#onMeshLoadedHandler">onMeshLoadedHandler</a></li><li data-type='method'><a href="NVController.html#onMeshPropertyChanged">onMeshPropertyChanged</a></li><li data-type='method'><a href="NVController.html#onMeshShaderChanged">onMeshShaderChanged</a></li><li data-type='method'><a href="NVController.html#onOpacityChangeHandler">onOpacityChangeHandler</a></li><li data-type='method'><a href="NVController.html#onVolumeAddedFromUrlHandler">onVolumeAddedFromUrlHandler</a></li><li data-type='method'><a href="NVController.html#onVolumeWithUrlRemovedHandler">onVolumeWithUrlRemovedHandler</a></li><li data-type='method'><a href="NVController.html#onZoom3DChangeHandler">onZoom3DChangeHandler</a></li></ul></li><li><a href="NVDocument.html">NVDocument</a><ul class='methods'><li data-type='method'><a href="NVDocument.html#addImageOptions">addImageOptions</a></li><li data-type='method'><a href="NVDocument.html#download">download</a></li><li data-type='method'><a href="NVDocument.html#getImageOptions">getImageOptions</a></li><li data-type='method'><a href="NVDocument.html#hasImage">hasImage</a></li><li data-type='method'><a href="NVDocument.html#hasImageFromUrl">hasImageFromUrl</a></li><li data-type='method'><a href="NVDocument.html#json">json</a></li><li data-type='method'><a href="NVDocument.html#removeImage">removeImage</a></li><li data-type='method'><a href="NVDocument.html#.deserializeMeshDataObjects">deserializeMeshDataObjects</a></li><li data-type='method'><a href="NVDocument.html#.loadFromJSON">loadFromJSON</a></li></ul></li><li></li><li></li><li><a href="NVLabel3D_NVLabel3D.html">NVLabel3D</a></li><li><a href="NVLabel3DStyle.html">NVLabel3DStyle</a></li><li><a href="NVMesh.html">NVMesh</a><ul class='methods'><li data-type='method'><a href="NVMesh.html#.loadFromBase64">loadFromBase64</a></li><li data-type='method'><a href="NVMesh.html#.loadFromFile">loadFromFile</a></li><li data-type='method'><a href="NVMesh.html#.loadFromUrl">loadFromUrl</a></li></ul></li><li><a href="global.html#NVMeshFromUrlOptions">NVMeshFromUrlOptions</a></li><li><a href="NVMeshLoaders.html">NVMeshLoaders</a></li><li><a href="NVMeshUtilities.html">NVMeshUtilities</a></li><li><a href="NVMessage.html">NVMessage</a></li><li><a href="NVMessageSet4DVolumeIndexData.html">NVMessageSet4DVolumeIndexData</a></li><li><a href="NVMesssageUpdateData.html">NVMesssageUpdateData</a></li><li><a href="NVUtilities.html">NVUtilities</a></li><li><a href="NiivueObject3D.html">NiivueObject3D</a></li><li><a href="SessionBus.html">SessionBus</a></li><li><a href="SessionUser.html">SessionUser</a></li><li><a href="Shader.html">Shader</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DRAG_MODE">DRAG_MODE</a></li><li><a href="global.html#LabelLineTerminator">LabelLineTerminator</a></li><li><a href="global.html#LabelTextAlignment">LabelTextAlignment</a></li><li><a href="global.html#MULTIPLANAR_TYPE">MULTIPLANAR_TYPE</a></li><li><a href="global.html#MeshType">MeshType</a></li><li><a href="global.html#NVMESSAGE">NVMESSAGE</a></li><li><a href="global.html#SLICE_TYPE">SLICE_TYPE</a></li><li><a href="global.html#storageAvailable">storageAvailable</a></li><li><a href="global.html#utiltiesLogger">utiltiesLogger</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">session-bus.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { webSocket } from 'rxjs/webSocket'

/**
 * @class SessionUser
 * @type SessionUser
 * @description SessionUser specifies display name, user id and user key
 * @param {string} displayName
 * @param {string} userId
 * @param {string} userKey Used to protect user properties
 * @param {Map} userProperties
 */
export class SessionUser {
  constructor(displayName = undefined, userId = undefined, userKey = undefined, userProperties = undefined) {
    this.id = userId || crypto.randomUUID()
    this.displayName = displayName || `user-${this.id}`
    this.key = userKey || crypto.randomUUID()
    this.properties = userProperties || new Map()
  }
}

/**
 * Checks if local storage is available
 * @param {string} type type of local storage requested
 * @returns {boolean}
 */
function storageAvailable(type) {
  let storage
  try {
    storage = window[type]
    const x = '__storage_test__'
    storage.setItem(x, x)
    storage.removeItem(x)
    return true
  } catch (e) {
    return (
      e instanceof DOMException &amp;&amp;
      // everything except Firefox
      (e.code === 22 ||
        // Firefox
        e.code === 1014 ||
        // test name field too, because code might not be present
        // everything except Firefox
        e.name === 'QuotaExceededError' ||
        // Firefox
        e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &amp;&amp;
      // acknowledge QuotaExceededError only if there's something already stored
      storage &amp;&amp;
      storage.length !== 0
    )
  }
}

/**
 * @class SessionBus
 * @type SessionBus
 * @description SessionBus is for synchronizing both remote and local instances
 * @constructor
 * @param {string} name
 * @param {SessionUser} user
 * @param {function} onMessageCallback  call back for new messages
 * @param {string} serverURL
 */
export class SessionBus {
  constructor(name, user, onMessageCallback, serverURL = '', sessionKey = '') {
    this.userList = []
    this.user = user || new SessionUser('anonymous')

    this.onMessageCallBack = onMessageCallback

    this.isConnectedToServer = false
    this.isController = false

    this.sessionScene = {}
    this.sessionKey = sessionKey || crypto.randomUUID()

    this.sessionName = name
    this.sessionSceneName = `session-${name}-scene`

    if (serverURL) {
      // remote
      this.serverConnection$ = null
      this.connectToServer(serverURL, name)
      this.subscribeToServer()
      this.isConnectedToServer = true
      this.serverConnection$.next({
        op: SessionBus.MESSAGE.CREATE,
        key: this.sessionKey
      })
    } else {
      // local
      if (!storageAvailable('localStorage')) {
        throw new Error('Local storage unavailable')
      }

      this.userQueueName = `user-${this.user.id}-q`
      this.userListName = `${name}-user-list`

      // add our user to the list
      this.userList = JSON.parse(localStorage.getItem(this.userListName) || '[]')
      this.userList.push(this.user)
      localStorage.setItem(this.userListName, JSON.stringify(this.userList))

      // create our message queue
      localStorage.setItem(this.userQueueName, JSON.stringify([]))

      window.addEventListener('storage', this.localStorageEventListener.bind(this))
    }
  }

  sendSessionMessage(message) {
    message.from = this.userId
    if (this.isConnectedToServer) {
      this.serverConnection$.next({
        ...message,
        key: this.sessionKey,
        userKey: this.userKey
      })
    } else {
      this.sendLocalMessage(message)
    }
  }

  // Remote
  // not included in public docs
  // Internal function to connect to web socket server
  connectToServer(serverURL, sessionName) {
    const url = new URL(serverURL)
    url.pathname = 'websockets'
    url.search = '?session=' + sessionName
    this.serverConnection$ = webSocket(url.href)
    console.log(url.href)
  }

  // Internal function called after a connection with the server has been made
  subscribeToServer() {
    this.serverConnection$.subscribe({
      next: (msg) => {
        this.onMessageCallBack(msg)
      }, // Called whenever there is a message from the server.
      error: (err) => console.log(err), // Called if at any point WebSocket API signals some kind of error.
      complete: () => console.log('complete') // Called when connection is closed (for whatever reason).
    })
  }

  sendLocalMessage(message) {
    // add the message for each client
    for (const user of this.userList) {
      if (user.id === this.userId) {
        continue
      }
      const userQueueName = `user-${user.id}-q`
      const userQueueText = localStorage.getItem(userQueueName)
      const userQueue = userQueueText ? JSON.parse(userQueueText) : []
      userQueue.push(message)
      localStorage.setItem(userQueueName, JSON.stringify(userQueue))
    }
  }

  localStorageEventListener(e) {
    // is this message for us?
    switch (e.key) {
      case this.userListName:
        {
          this.userList = JSON.parse(e.newValue)
          // compare new and old values
          const newUsers = JSON.parse(e.newValue).filter(
            (u) =>
              !JSON.parse(e.oldValue)
                .map((o) => o.id)
                .includes(u.id)
          )
          for (const newUser of newUsers) {
            this.onMessageCallBack({
              op: 'user joined',
              user: newUser
            })
          }
        }
        break
      case this.userQueueName:
        {
          const messages = JSON.parse(e.newValue)
          for (const message of messages) {
            if (this.onMessageCallBack) {
              this.onMessageCallBack(message)
            }
          }
          // reset our message queue
          localStorage.setItem(this.userQueueName, [])
        }
        break
    }
  }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Tue Nov 28 2023 10:46:27 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
